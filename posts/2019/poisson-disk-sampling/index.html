<!doctype html>
<html lang='en'>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="a5huynh" />

  
<meta name="title" content="Generating Blue Noise w&#x2F; Poisson Disk Sampling" />
<meta name="description" content="&lt;p&gt;&amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;www.redblobgames.com&#x2F;articles&#x2F;noise&#x2F;introduction.html#colors&quot;&gt;Blue noise&lt;&#x2F;a&gt;&amp;quot; is a term used in computer graphics to describe
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Image_noise#Quantization_noise_(uniform_noise)&quot;&gt;noise&lt;&#x2F;a&gt; that is uniformly distributed. It is often used in
procedural generation techniques to place objects during terrain generation
that require a roughly even distribution across a landscape. This post will go
into an implementation of Poisson Disk sampling, a super straightforward
blue noise generator that I&#x27;ve been using on recent projects. ðŸ˜„&lt;&#x2F;p&gt;
" />

<meta property="og:title" content="Generating Blue Noise w&#x2F; Poisson Disk Sampling" />
<meta property="og:description" content="&lt;p&gt;&amp;quot;&lt;a href=&quot;https:&#x2F;&#x2F;www.redblobgames.com&#x2F;articles&#x2F;noise&#x2F;introduction.html#colors&quot;&gt;Blue noise&lt;&#x2F;a&gt;&amp;quot; is a term used in computer graphics to describe
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Image_noise#Quantization_noise_(uniform_noise)&quot;&gt;noise&lt;&#x2F;a&gt; that is uniformly distributed. It is often used in
procedural generation techniques to place objects during terrain generation
that require a roughly even distribution across a landscape. This post will go
into an implementation of Poisson Disk sampling, a super straightforward
blue noise generator that I&#x27;ve been using on recent projects. ðŸ˜„&lt;&#x2F;p&gt;
" />
<meta property="og:type" content="website" />


  <title>Generating Blue Noise w&#x2F; Poisson Disk Sampling</title>
  <link rel="icon" href="&#x2F;favicon&#x2F;favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&family=Inconsolata&display=swap" rel="stylesheet">
  <link rel="stylesheet" href='https://a5huynh.github.io/blog.css' type="text/css">
  </head>
<body>
  <div class='header'>
    <div id='big-name'>
      <a href='/'>Andrew Huynh</a>
    </div>
    <div id='my-attrs'>
      <div>Thoughts&nbsp;</div>
      <div>and ramblings.</div>
    </div>
    <div id='social-icons'>
      <div>
        <a
          href='http://www.google.com/recaptcha/mailhide/d?k=01uNCZrwDlz2I3VKthc1vVRw==&amp;c=6YTbdnM2V4n_HnbJamUSEoWCPMs3doQFXFC1r8BFdkU='>
          <img src='https://a5huynh.github.io/img/email.svg' alt='Email me!'>
        </a>
      </div>
      <div>
        <a href='http://twitter.com/a5huynh'>
          <img src='https://a5huynh.github.io/img/twitter.svg' alt='Follow me on Twitter!'>
        </a>
      </div>
      <div>
        <a href='http://www.linkedin.com/profile/view?id=30602610'>
          <img src='https://a5huynh.github.io/img/linkedin.svg' alt='Check me out on LinkedIn.'>
        </a>
      </div>
    </div>
  </div>
  
<div class='article'>
  <h1>Generating Blue Noise w&#x2F; Poisson Disk Sampling</h1>
  <p class='meta'>
    2019 May 16 - San Francisco |
    <span>2841 words</span>
  </p>
  
  

<div class='post-tags'>
    
    <a href='https://a5huynh.github.io/tags/rustlang/'>
        <span
            >
            #rustlang
        </span>
    </a>
    
    <a href='https://a5huynh.github.io/tags/procgen/'>
        <span
            >
            #procgen
        </span>
    </a>
    
</div>


  

  <div class='post'>
    <p>&quot;<a href="https://www.redblobgames.com/articles/noise/introduction.html#colors">Blue noise</a>&quot; is a term used in computer graphics to describe
<a href="https://en.wikipedia.org/wiki/Image_noise#Quantization_noise_(uniform_noise)">noise</a> that is uniformly distributed. It is often used in
procedural generation techniques to place objects during terrain generation
that require a roughly even distribution across a landscape. This post will go
into an implementation of Poisson Disk sampling, a super straightforward
blue noise generator that I've been using on recent projects. ðŸ˜„</p>
<span id="continue-reading"></span><iframe scrolling="no" class="full-width" src="https://a5huynh.github.io/poisson-disk/examples/index.html"></iframe>
<blockquote>
<p>Hint: refresh to generate more points!</p>
<p>See my repo for the full source code <a href="https://github.com/a5huynh/poisson-disk">here</a></p>
</blockquote>
<p>First off, why would we use blue noise versus normal random number generation? If we
compare randomly generated points vs points generated via a blue noise function, weâ€™d
see something like the two images below.</p>
<p><img src="/img/2019/rng-example.png" alt="rng sampling example" />
<em>Random number generation, generated using Math.random()</em></p>
<p><img src="/img/2019/poisson-disk-example.png" alt="poisson disk sampling example" />
<em>Blue noise, generated using poisson disk sampling</em></p>
<p>We can see that points generated by the blue noise are able to maintain a minimum
distance from other points, creating a randomly generated yet more natural look and
feel when compared to points generated by random number generation. This is no fault
of the algorithm used in the random number generator, there are just no guarantees on
how evenly distributed the points will be.</p>
<h2 id="poisson-disk-sampling">Poisson Disk Sampling</h2>
<p>The blue noise example above was generated using the algorithm presented in
&quot;<a href="https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Fast Poisson Disk Sampling in Arbitrary Dimensions</a>&quot;. The
algorithm is linear w/ respect to the number of points generated (i.e.
fast ðŸš€!), easy to understand, and easy to implement so letâ€™s dive in!</p>
<h3 id="algorithm-input">Algorithm input</h3>
<p>The poisson disk sampler requires only a couple parameters to get started.</p>
<ol>
<li>First we need \(n\), the domain in which the numbers will be generated (i.e. 2D
space or 3D space). For the sake of simplicity, weâ€™ll assume that all
points will be generated in 2D space, setting \(n = 2\).</li>
<li>The minimum distance \(r\) between samples.</li>
<li>A constant \(k\), the number of samples to choose before rejection.</li>
</ol>
<p>Converting this into <code>rust</code>, we'll get the the following:</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#66d9ef;">struct </span><span>PoissonDisk {
</span></td></tr><tr><td>2</td><td><span>    </span><span style="color:#f92672;">pub </span><span>minimum_distance: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>3</td><td><span>    </span><span style="color:#f92672;">pub </span><span>num_samples: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>4</td><td><span>}
</span></td></tr><tr><td>5</td><td><span>
</span></td></tr><tr><td>6</td><td><span style="font-style:italic;color:#66d9ef;">impl </span><span>PoissonDisk {
</span></td></tr><tr><td>7</td><td><span>    </span><span style="color:#f92672;">pub </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">new</span><span>(</span><span style="font-style:italic;color:#fd971f;">r</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">k</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>) -&gt; </span><span style="font-style:italic;color:#66d9ef;">Self </span><span>{
</span></td></tr><tr><td>8</td><td><span>        PoissonDisk {
</span></td></tr><tr><td>9</td><td><span>            minimum_distance: r,
</span></td></tr><tr><td>10</td><td><span>            num_samples: k,
</span></td></tr><tr><td>11</td><td><span>        }
</span></td></tr><tr><td>12</td><td><span>    }
</span></td></tr><tr><td>13</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<h3 id="keeping-track-of-sampled-points">Keeping track of sampled points</h3>
<p>As part of the initialization process, we'll need to create a grid that is
used to store sampled points and to speed up spatial searches. The size of
each cell in the grid is directly related to the radius \(r\) and the
domain \(n\). In the case of a 2D grid for our example implementation, each
cell is bounded by \(\frac{r}{\sqrt{2}}\) so that each grid cell will
contain at most a single sample.</p>
<p>To understand why we use \(\frac{r}{\sqrt{2}}\) as the cell size, the insight
lies in the fact that we want each cell to hold at most one point. So what is
the longest possible distance between two points in adjacent cells? The worst case
would be two points on opposite ends of the cell diagonal. Since this diagonal should
never exceed \(r\), we can use some geometry to solve the length of the sides:</p>
<p>\begin{align}
x^2 + x^2 = r^2\
2x^2 = r^2\
x^2 = \frac{r^2}{2}\
x = \frac{r}{\sqrt{2}}\
\end{align}</p>
<p>Generalizing this to the domain \(n\) we see how the original formulation
comes out to be \(\frac{r}{\sqrt{n}}\)!</p>
<p>In our <code>rust</code> implementation, weâ€™ll represent the grid as a
<code>Vec&lt;Option&lt;(usize, usize)&gt;&gt;</code>. Each cell can either be <code>None</code> or the
sampled point <code>(usize, usize)</code>. Building on the example code we had before,
the <code>struct</code> and <code>new</code> function should now look like below:</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#66d9ef;">struct </span><span>PoissonDisk {
</span></td></tr><tr><td>2</td><td><span>    ..., </span><span style="color:#75715e;">// fields from before
</span></td></tr><tr><td>3</td><td><span>    width: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>4</td><td><span>    height: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>5</td><td><span>    cell_size: </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>,
</span></td></tr><tr><td>6</td><td><span>    grid_width: </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>,
</span></td></tr><tr><td>7</td><td><span>    grid_height: </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>,
</span></td></tr><tr><td>8</td><td><span>    grid: </span><span style="font-style:italic;color:#66d9ef;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#66d9ef;">Option</span><span>&lt;(</span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>)&gt;&gt;,
</span></td></tr><tr><td>9</td><td><span>    samples: </span><span style="font-style:italic;color:#66d9ef;">Vec</span><span>&lt;(</span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>)&gt;,
</span></td></tr><tr><td>10</td><td><span>}
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span style="font-style:italic;color:#66d9ef;">impl </span><span>PoissonDisk {
</span></td></tr><tr><td>13</td><td><span>    </span><span style="color:#f92672;">pub </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">new</span><span>(</span><span style="font-style:italic;color:#fd971f;">w</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">h</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">r</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">k</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>) -&gt; </span><span style="font-style:italic;color:#66d9ef;">Self </span><span>{
</span></td></tr><tr><td>14</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> cell_size </span><span style="color:#f92672;">=</span><span> r </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>(</span><span style="color:#ae81ff;">2.0 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>).</span><span style="color:#66d9ef;">sqrt</span><span>();
</span></td></tr><tr><td>15</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> grid_width </span><span style="color:#f92672;">= </span><span>(w </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/</span><span> cell_size).</span><span style="color:#66d9ef;">ceil</span><span>() </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1.0</span><span>;
</span></td></tr><tr><td>16</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> grid_height </span><span style="color:#f92672;">= </span><span>(j </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/</span><span> cell_size).</span><span style="color:#66d9ef;">ceil</span><span>() </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1.0</span><span>;
</span></td></tr><tr><td>17</td><td><span>
</span></td></tr><tr><td>18</td><td><span>        PoissonDisk {
</span></td></tr><tr><td>19</td><td><span>            </span><span style="color:#f92672;">...</span><span>,
</span></td></tr><tr><td>20</td><td><span>            width: w,
</span></td></tr><tr><td>21</td><td><span>            height: h,
</span></td></tr><tr><td>22</td><td><span>            cell_size, grid_width, grid_height,
</span></td></tr><tr><td>23</td><td><span>            grid: vec![</span><span style="font-style:italic;color:#66d9ef;">None</span><span>; (grid_width </span><span style="color:#f92672;">*</span><span> grid_height) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>],
</span></td></tr><tr><td>24</td><td><span>        }
</span></td></tr><tr><td>25</td><td><span>    }
</span></td></tr><tr><td>26</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Next, weâ€™ll create a utility function to insert new points into the grid
since it involves a bit of math each time. We need to determine which cell
in the grid to place a point, so weâ€™ll scale the point to determine the
grid coordinates by dividing the point coordinates by the <code>cell_size</code> and
calculate the index into the grid array. Now every time we generate a new
point, we can simply call <code>self.insert_point(new_point)</code> to add the point
to the grid.</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">insert_point</span><span>(</span><span style="color:#f92672;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">point</span><span>: (</span><span style="font-style:italic;color:#fd971f;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">usize</span><span>)) {
</span></td></tr><tr><td>2</td><td><span>    </span><span style="color:#75715e;">// Calculate the (x, y) coordinate when place inside the grid.
</span></td></tr><tr><td>3</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> cell_x </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">0 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.cell_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span></td></tr><tr><td>4</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> cell_y </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.cell_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span></td></tr><tr><td>5</td><td><span>    </span><span style="color:#75715e;">// Calculate the index within our flat array and place the point
</span></td></tr><tr><td>6</td><td><span>    </span><span style="color:#75715e;">// there.
</span></td></tr><tr><td>7</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> cell_idx </span><span style="color:#f92672;">= </span><span>(cell_y </span><span style="color:#f92672;">* </span><span>self.cell_width </span><span style="color:#f92672;">+</span><span> cell_x) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span></td></tr><tr><td>8</td><td><span>    self.grid[cell_idx] </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">Some</span><span>(point);
</span></td></tr><tr><td>9</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<h3 id="selecting-an-initial-point">Selecting an initial point</h3>
<p>For the next step of the algorithm, we need to select an initial sample.
This will be randomly chosen uniformly from the domain, inserted into the
grid, and used as the initial point on the &quot;active list&quot;.</p>
<p>First, letâ€™s add the <a href="https://crates.io/crates/rand">rand</a> crate to our
dependencies in our <code>Cargo.toml</code> file.</p>
<pre data-lang="toml" style="background-color:#272822;color:#f8f8f2;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#f92672;">rand </span><span>= </span><span style="color:#e6db74;">&quot;0.6.5&quot;
</span></code></pre>
<p>Afterwards, modify the <code>new</code> function so that we generate a new point after
initializing the <code>PoissonDisk</code> struct, adding it to both grid and active
list.</p>
<p>Putting it all together with the example code that we have so far, the
<code>new</code> function should look a little something like below.</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#f92672;">use</span><span> rand;
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span style="font-style:italic;color:#66d9ef;">struct </span><span>PoissonDisk {
</span></td></tr><tr><td>4</td><td><span>    ...,
</span></td></tr><tr><td>5</td><td><span>    </span><span style="color:#75715e;">// &quot;Active list&quot; used to keep track of sampled points we are able
</span></td></tr><tr><td>6</td><td><span>    </span><span style="color:#75715e;">// to generate new points around.
</span></td></tr><tr><td>7</td><td><span>    active: </span><span style="font-style:italic;color:#66d9ef;">Vec</span><span>&lt;(</span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>)&gt;
</span></td></tr><tr><td>8</td><td><span>}
</span></td></tr><tr><td>9</td><td><span>
</span></td></tr><tr><td>10</td><td><span style="font-style:italic;color:#66d9ef;">impl </span><span>PoissonDisk {
</span></td></tr><tr><td>11</td><td><span>    </span><span style="color:#f92672;">pub </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">new</span><span>(</span><span style="font-style:italic;color:#fd971f;">w</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">h</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">r</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">k</span><span>: </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>) -&gt; </span><span style="font-style:italic;color:#66d9ef;">Self </span><span>{
</span></td></tr><tr><td>12</td><td><span>        </span><span style="color:#75715e;">// Instead of immediately returning the newly construct struct
</span></td></tr><tr><td>13</td><td><span>        </span><span style="color:#75715e;">// let store it in a variable and generate the initial point.
</span></td></tr><tr><td>14</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> disk </span><span style="color:#f92672;">=</span><span> PoissonDisk {
</span></td></tr><tr><td>15</td><td><span>            </span><span style="color:#f92672;">...</span><span>,
</span></td></tr><tr><td>16</td><td><span>            active: </span><span style="font-style:italic;color:#66d9ef;">Vec</span><span>::new(),
</span></td></tr><tr><td>17</td><td><span>        };
</span></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td>19</td><td><span>        </span><span style="color:#75715e;">// Here we generate the new point.
</span></td></tr><tr><td>20</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> rng </span><span style="color:#f92672;">= </span><span>rand::thread_rng();
</span></td></tr><tr><td>21</td><td><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> point </span><span style="color:#f92672;">= </span><span>(
</span></td></tr><tr><td>22</td><td><span>            (rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;() </span><span style="color:#f92672;">*</span><span> w </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>23</td><td><span>            (rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;() </span><span style="color:#f92672;">*</span><span> h </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize
</span></td></tr><tr><td>24</td><td><span>        );
</span></td></tr><tr><td>25</td><td><span>
</span></td></tr><tr><td>26</td><td><span>        </span><span style="color:#75715e;">// Add point to grid &amp; active list.
</span></td></tr><tr><td>27</td><td><span>        disk.</span><span style="color:#66d9ef;">insert_point</span><span>(point);
</span></td></tr><tr><td>28</td><td><span>        disk.active.</span><span style="color:#66d9ef;">push</span><span>(point);
</span></td></tr><tr><td>29</td><td><span>
</span></td></tr><tr><td>30</td><td><span>        disk
</span></td></tr><tr><td>31</td><td><span>    }
</span></td></tr><tr><td>32</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<h3 id="sampling-points-point-validation">Sampling points &amp; point validation</h3>
<p>Finally ðŸŽ‰! Now that we have the ability to keep track of points, sources
for new points, and an initial sample to get started we can start
implementing the core of the algorithm (<strong>Step 2</strong> in the paper).</p>
<p>This step involves a loop where:</p>
<ol>
<li>We take a random point from the active list</li>
<li>Sample \(r\) points around the active point</li>
<li>If none of the points are outside \(r\) of nearby points, remove this
point from the active list.</li>
<li>Otherwise, add points to active list and continue.</li>
<li>Repeat until there are no more points on the active list.</li>
</ol>
<p>Breaking down the loop step by step, we'll first tackle randomly selecting a point
from the active list. Given an active list of length \(l\), we randomly
choose an index between \(0\) and \(l - 1\).</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#75715e;">// Generate a random index in our active list.
</span></td></tr><tr><td>2</td><td><span style="font-style:italic;color:#66d9ef;">let</span><span> idx </span><span style="color:#f92672;">=</span><span> rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;() </span><span style="color:#f92672;">* </span><span>(self.active.</span><span style="color:#66d9ef;">len</span><span>() </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>;
</span></td></tr><tr><td>3</td><td><span style="font-style:italic;color:#66d9ef;">let</span><span> source </span><span style="color:#f92672;">= </span><span>self.active[idx </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>];
</span></td></tr></tbody></table></code></pre>
<p>Next, we need to sample \(k\) new points around the source point. When
generating a new point, we randomly choose a point that is between \(r\)
and \(2r\) of the source point. This will make it so that new points will
always be at least \(r\) length away from the current point. To visualize
how this will look on the grid we've created, here's a visualization of the
disk where valid points could possible be generated.</p>
<p><img src="/img/2019/range.png" alt="example of sampling disk" />
<em>Generated points will appear in a disk that is \(r\) is size around the
source point. Notice that it overlaps approximately 2 squares away from the
source point. This will be important later on when we validate new points.</em></p>
<p>The trick to sampling a point inside this disk is to use <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar
coordinates</a>! Polar coordinates are represented by a distance
and angle from a reference point (see image below for an example). Using
the source point as our reference point, we randomly choose an angle and a
random radius that is between \(r\) and \(2r\) and convert this back into
cartesian coordinates.</p>
<p><img src="/img/2019/polar-coordinates.png" alt="polar coordinates example" />
<em>An example of polar coordinates in action courtesy of Wikipedia</em></p>
<p>Using this knowledge, lets create a new function, <code>generate_around</code>,
that will generate new points around the source point:</p>
<pre data-linenos data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">generate_around</span><span>(</span><span style="color:#f92672;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">pt</span><span>: (</span><span style="font-style:italic;color:#fd971f;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">usize</span><span>)) -&gt; (</span><span style="font-style:italic;color:#66d9ef;">usize</span><span>, </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>) {
</span></td></tr><tr><td>2</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> rng </span><span style="color:#f92672;">= </span><span>rand::thread_rng();
</span></td></tr><tr><td>3</td><td><span>    </span><span style="color:#75715e;">// Random angle
</span></td></tr><tr><td>4</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> angle </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">2.0 </span><span style="color:#f92672;">* </span><span style="color:#ae81ff;">PI </span><span style="color:#f92672;">*</span><span> rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;();
</span></td></tr><tr><td>5</td><td><span>    </span><span style="color:#75715e;">// Random radius between r and 2r
</span></td></tr><tr><td>6</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> radius </span><span style="color:#f92672;">= </span><span>self.min_dist </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">* </span><span>(rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;() </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">1.0</span><span>);
</span></td></tr><tr><td>7</td><td><span>    </span><span style="color:#75715e;">// Convert polar coordinates to cartesian and viola,
</span></td></tr><tr><td>8</td><td><span>    </span><span style="color:#75715e;">// a new point is generated around the source point (x, y)
</span></td></tr><tr><td>9</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> new_x </span><span style="color:#f92672;">=</span><span> pt.</span><span style="color:#ae81ff;">0 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">+ </span><span>(radius </span><span style="color:#f92672;">*</span><span> angle.</span><span style="color:#66d9ef;">cos</span><span>());
</span></td></tr><tr><td>10</td><td><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> new_y </span><span style="color:#f92672;">=</span><span> pt.</span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">+ </span><span>(radius </span><span style="color:#f92672;">*</span><span> angle.</span><span style="color:#66d9ef;">sin</span><span>());
</span></td></tr><tr><td>11</td><td><span>    </span><span style="color:#75715e;">// Using min/max, we&#39;ll also constrain the new point to be within
</span></td></tr><tr><td>12</td><td><span>    </span><span style="color:#75715e;">// the bounds of our grid.
</span></td></tr><tr><td>13</td><td><span>    (
</span></td></tr><tr><td>14</td><td><span>        new_x.</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.width </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>15</td><td><span>        new_y.</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.height </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>,
</span></td></tr><tr><td>16</td><td><span>    )
</span></td></tr><tr><td>17</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Now that we have a new point, how do make sure it's a &quot;valid&quot; point?</p>
<p>Valid new points satisfy two constraints:</p>
<ol>
<li>They should not be within \(r\) of any existing point.</li>
<li>They must exist within the <code>width</code>/<code>height</code> bounds.</li>
</ol>
<p>Note that in our <code>generate_around</code> function we already ensure that new points
are within our <code>width</code>/<code>height</code> bounds, so we only need to check if the point
exists within \(r\) of other points.</p>
<p>The grid that was shown earlier can be used to quickly search for
neighboring points. Lets bring back the image we used before to showcase
the disk area where sampled points will appear.</p>
<p><img src="/img/2019/range.png" alt="example of sampling disk" /></p>
<p>As mentioned before, each grid cell is sized in such a way that there
should only exist a single point in each cell. Since each cell is a smaller
than the radius (\(\frac{r}{\sqrt{2}}\)), the neighborhood around the
source cell will be at most 2 cells away.</p>
<p>To find the start and end coordinates of the neighborhood, we'll determine
where the point exists in the grid and +/- 2 from the coordinates.</p>
<pre data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#75715e;">// Scale the source point onto the grid.
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> xidx </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">0 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.grid_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> yidx </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.grid_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span><span style="color:#75715e;">// Determine the neighborhood around the source point.
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> start_x </span><span style="color:#f92672;">= </span><span>(xidx </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> end_x </span><span style="color:#f92672;">= </span><span>(xidx </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.grid_width </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> start_y </span><span style="color:#f92672;">= </span><span>(yidx </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span style="font-style:italic;color:#66d9ef;">let</span><span> end_y </span><span style="color:#f92672;">= </span><span>(yidx </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.grid_height </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span></code></pre>
<p>Using the cells in this neighborhood we can loop through the neighbors
of the source point and make sure our new point is outside the radius of
<em>any</em> nearby points without having to check all points. If no neighbors are
found or if we are outside the radius of each neighbor, this point is
valid.</p>
<p>Our <code>is_valid</code> function should now look like the following:</p>
<pre data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">is_valid</span><span>(</span><span style="color:#f92672;">&amp;</span><span style="font-style:italic;color:#fd971f;">self</span><span>, </span><span style="font-style:italic;color:#fd971f;">point</span><span>: (</span><span style="font-style:italic;color:#fd971f;">usize</span><span>, </span><span style="font-style:italic;color:#fd971f;">usize</span><span>)) -&gt; </span><span style="font-style:italic;color:#66d9ef;">bool </span><span>{
</span><span>    </span><span style="color:#75715e;">// Scale the source point onto the grid.
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> xidx </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">0 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.grid_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> yidx </span><span style="color:#f92672;">= </span><span>(point.</span><span style="color:#ae81ff;">1 </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span style="color:#f92672;">/ </span><span>self.grid_size).</span><span style="color:#66d9ef;">floor</span><span>();
</span><span>    </span><span style="color:#75715e;">// Determine the neighborhood around the source point.
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> start_x </span><span style="color:#f92672;">= </span><span>(xidx </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> end_x </span><span style="color:#f92672;">= </span><span>(xidx </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.grid_width </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> start_y </span><span style="color:#f92672;">= </span><span>(yidx </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">max</span><span>(</span><span style="color:#ae81ff;">0.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> end_y </span><span style="color:#f92672;">= </span><span>(yidx </span><span style="color:#f92672;">+ </span><span style="color:#ae81ff;">2.0</span><span>).</span><span style="color:#66d9ef;">min</span><span>(self.grid_height </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1.0</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>;
</span><span>    </span><span style="color:#75715e;">// Check all non-empty neighbors cells and make sure the new point
</span><span>    </span><span style="color:#75715e;">// is outside their radius.
</span><span>    </span><span style="color:#f92672;">for</span><span> y </span><span style="color:#f92672;">in</span><span> start_y</span><span style="color:#f92672;">..</span><span>end_y {
</span><span>        </span><span style="color:#f92672;">for</span><span> x </span><span style="color:#f92672;">in</span><span> start_x</span><span style="color:#f92672;">..</span><span>end_x {
</span><span>            </span><span style="font-style:italic;color:#66d9ef;">let</span><span> idx </span><span style="color:#f92672;">=</span><span> y </span><span style="color:#f92672;">* </span><span>self.grid_width </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize </span><span style="color:#f92672;">+</span><span> x;
</span><span>            </span><span style="color:#f92672;">if </span><span style="font-style:italic;color:#66d9ef;">let Some</span><span>(cell) </span><span style="color:#f92672;">= </span><span>self.grid[idx] {
</span><span>                </span><span style="color:#75715e;">// This is the standard distance formula between two points.
</span><span>                </span><span style="color:#f92672;">if </span><span style="color:#66d9ef;">distance</span><span>(cell, point) </span><span style="color:#f92672;">&lt;= </span><span>self.min_dist </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64 </span><span>{
</span><span>                    </span><span style="color:#f92672;">return </span><span style="color:#ae81ff;">false</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ae81ff;">true
</span><span>}
</span></code></pre>
<p>All that is left is to make sure any source point that were unable to generate
valid sample points is remove from our active list.</p>
<p>Putting it all together, the example code should now look like the following:</p>
<pre data-lang="rust" style="background-color:#272822;color:#f8f8f2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f92672;">pub </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">generate</span><span>(</span><span style="color:#f92672;">&amp;mut </span><span style="font-style:italic;color:#fd971f;">self</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> rng </span><span style="color:#f92672;">= </span><span>rand::thread_rng();
</span><span>    </span><span style="color:#f92672;">while !</span><span>self.active.</span><span style="color:#66d9ef;">is_empty</span><span>() {
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> idx </span><span style="color:#f92672;">=</span><span> rng.gen::&lt;</span><span style="font-style:italic;color:#66d9ef;">f64</span><span>&gt;() </span><span style="color:#f92672;">* </span><span>(self.active.</span><span style="color:#66d9ef;">len</span><span>() </span><span style="color:#f92672;">- </span><span style="color:#ae81ff;">1</span><span>) </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">f64</span><span>;
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> source </span><span style="color:#f92672;">= </span><span>self.active[idx </span><span style="color:#f92672;">as </span><span style="font-style:italic;color:#66d9ef;">usize</span><span>];
</span><span>        </span><span style="color:#75715e;">// Did we find an valid samples?
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> found </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">false</span><span>;
</span><span>        </span><span style="color:#f92672;">for _ in </span><span style="color:#ae81ff;">0</span><span style="color:#f92672;">..</span><span>self.num_samples {
</span><span>            </span><span style="font-style:italic;color:#66d9ef;">let</span><span> new_point </span><span style="color:#f92672;">= </span><span>self.</span><span style="color:#66d9ef;">generate_around</span><span>(source);
</span><span>            </span><span style="color:#75715e;">// Add the new point to the grid and active list if
</span><span>            </span><span style="color:#75715e;">// the point is valid.
</span><span>            </span><span style="color:#f92672;">if </span><span>self.</span><span style="color:#66d9ef;">is_valid</span><span>(new_point) {
</span><span>                </span><span style="color:#75715e;">// Add point to our background grid
</span><span>                self.</span><span style="color:#66d9ef;">insert_point</span><span>(new_point);
</span><span>                </span><span style="color:#75715e;">// Add point to our active list
</span><span>                self.active.</span><span style="color:#66d9ef;">push</span><span>(new_point);
</span><span>                </span><span style="color:#75715e;">// Add point to our list of sampled points
</span><span>                self.samples.</span><span style="color:#66d9ef;">push</span><span>(new_point);
</span><span>                found </span><span style="color:#f92672;">= </span><span style="color:#ae81ff;">true</span><span>;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#75715e;">// If not valid points are found, remove the source point
</span><span>        </span><span style="color:#75715e;">// from the active list.
</span><span>        </span><span style="color:#f92672;">if !</span><span>found {
</span><span>            self.active.</span><span style="color:#66d9ef;">remove</span><span>(idx);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>And there you have it! Check out the <a href="https://github.com/a5huynh/poisson-disk">code repo</a> to view the
code in it's entirety along w/ the WASM visualization that was used for
this page.</p>

  </div>
  <span id='#thats-all-folks'>&#8718;</span>
</div>
<div class='footer'>
    Rabble-rouser.<br>
    Follow me on <a rel="me" href="https://mastodon.social/@a5huynh">Mastodon</a>.<br>
    Founder @ <a href='https://spyglass.fyi'>Spyglass Search</a>.<br>
    Like what you see? My website is <a href='https://github.com/a5huynh/a5huynh.github.com'>open source!</a>
  </div>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
</body>
</html>